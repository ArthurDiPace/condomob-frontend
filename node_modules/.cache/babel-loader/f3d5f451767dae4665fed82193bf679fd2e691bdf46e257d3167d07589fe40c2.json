{"ast":null,"code":"import moment from 'moment';\nexport default {\n  computed: {\n    user() {\n      return JSON.parse(localStorage.getItem('semob@user'));\n    }\n  },\n  methods: {\n    handleError(error) {\n      if (error.response.status == 400) {\n        const mensagensErro = error.response.data;\n        let listErrors = {};\n        for (let itemErro in mensagensErro) {\n          if (itemErro == 'non_field_errors') {\n            this.$toast.open({\n              message: mensagensErro[itemErro].join(','),\n              type: 'error'\n            });\n          } else {\n            listErrors[itemErro] = mensagensErro[itemErro];\n          }\n        }\n        return listErrors;\n      } else if (error.response.status == 403) {\n        this.$toast.open({\n          message: 'Você não tem permissão para executar esta ação',\n          type: 'error'\n        });\n        return {};\n      } else {\n        this.$toast.open({\n          message: 'Ocorreu um erro no servidor',\n          type: 'error'\n        });\n        return {};\n      }\n    },\n    handleBlobError(error) {\n      if (error.request.responseType === 'blob' && error.response.data instanceof Blob && error.response.data.type && error.response.data.type.toLowerCase().includes('json')) {\n        const reader = new FileReader();\n        const promise = new Promise((resolve, reject) => {\n          reader.onload = () => {\n            try {\n              const parsedData = JSON.parse(reader.result);\n              error.response.data = parsedData;\n              reject(error);\n            } catch (parseError) {\n              reject(parseError);\n            }\n          };\n          reader.onerror = () => {\n            reject(error);\n          };\n          reader.readAsText(error.response.data);\n        });\n        promise.catch(err => {\n          this.$toast.open({\n            message: err.response.data,\n            type: 'error'\n          });\n        });\n      }\n    },\n    formatDateTime(date) {\n      if (!date) return null;\n      return moment(date).format('DD/MM/YYYY HH:mm:ss');\n    },\n    formatDateTimeWithoutSeconds(date) {\n      if (!date) return null;\n      return moment(date).format('DD/MM/YYYY HH:mm');\n    },\n    formatDateTimeToDate(date) {\n      if (!date) return null;\n      return moment(date).format('DD/MM/YYYY');\n    },\n    getFormData(object) {\n      const formData = new FormData();\n      Object.keys(object).forEach(key => (object[key] || object.id) && formData.append(key, object[key]));\n      return formData;\n    }\n  }\n};","map":{"version":3,"names":["moment","computed","user","JSON","parse","localStorage","getItem","methods","handleError","error","response","status","mensagensErro","data","listErrors","itemErro","$toast","open","message","join","type","handleBlobError","request","responseType","Blob","toLowerCase","includes","reader","FileReader","promise","Promise","resolve","reject","onload","parsedData","result","parseError","onerror","readAsText","catch","err","formatDateTime","date","format","formatDateTimeWithoutSeconds","formatDateTimeToDate","getFormData","object","formData","FormData","Object","keys","forEach","key","id","append"],"sources":["src/mixins/GenericMixin.vue"],"sourcesContent":["<script>\nimport moment from 'moment'\n\nexport default {\n  computed: {\n    user() {\n      return JSON.parse(localStorage.getItem('semob@user'))\n    }\n  },\n  methods: {\n    handleError(error) {\n      if (error.response.status == 400) {\n        const mensagensErro = error.response.data\n        let listErrors = {}\n        for (let itemErro in mensagensErro) {\n          if (itemErro == 'non_field_errors') {\n            this.$toast.open({\n                message: mensagensErro[itemErro].join(','),\n                type: 'error',\n            })\n          } else {\n            listErrors[itemErro] = mensagensErro[itemErro]\n          }\n        }\n        return listErrors\n      } else if (error.response.status == 403) {\n        this.$toast.open({\n          message: 'Você não tem permissão para executar esta ação',\n          type: 'error',\n        })\n        return {}\n      } else {\n        this.$toast.open({\n          message: 'Ocorreu um erro no servidor',\n          type: 'error',\n        })\n        return {}\n      }\n    },\n    handleBlobError(error) {\n      if (\n        error.request.responseType === 'blob' &&\n        error.response.data instanceof Blob &&\n        error.response.data.type &&\n        error.response.data.type.toLowerCase().includes('json')\n      ) {\n        const reader = new FileReader();\n\n        const promise = new Promise((resolve, reject) => {\n          reader.onload = () => {\n            try {\n              const parsedData = JSON.parse(reader.result);\n              error.response.data = parsedData;\n              reject(error);\n            } catch (parseError) {\n              reject(parseError);\n            }\n          };\n\n          reader.onerror = () => {\n            reject(error);\n          };\n\n          reader.readAsText(error.response.data);\n        });\n\n        promise.catch((err) => {\n          this.$toast.open({\n            message: err.response.data,\n            type: 'error',\n          });\n        });\n      }\n    },\n    formatDateTime(date) {\n      if (!date) return null\n      return moment(date).format('DD/MM/YYYY HH:mm:ss')\n    },\n    formatDateTimeWithoutSeconds(date) {\n      if (!date) return null\n      return moment(date).format('DD/MM/YYYY HH:mm')\n    },\n    formatDateTimeToDate(date) {\n      if (!date) return null\n      return moment(date).format('DD/MM/YYYY')\n    },\n    getFormData(object) {\n      const formData = new FormData()\n      Object.keys(object).forEach(\n        key => (object[key] || object.id) && formData.append(key, object[key])\n      )\n      return formData\n    },\n  },\n}\n</script>\n\n<style>\n.v-toast__text {\n  font-family: Roboto, sans-serif;\n}\n</style>"],"mappings":"AACA,OAAAA,MAAA;AAEA;EACAC,QAAA;IACAC,KAAA;MACA,OAAAC,IAAA,CAAAC,KAAA,CAAAC,YAAA,CAAAC,OAAA;IACA;EACA;EACAC,OAAA;IACAC,YAAAC,KAAA;MACA,IAAAA,KAAA,CAAAC,QAAA,CAAAC,MAAA;QACA,MAAAC,aAAA,GAAAH,KAAA,CAAAC,QAAA,CAAAG,IAAA;QACA,IAAAC,UAAA;QACA,SAAAC,QAAA,IAAAH,aAAA;UACA,IAAAG,QAAA;YACA,KAAAC,MAAA,CAAAC,IAAA;cACAC,OAAA,EAAAN,aAAA,CAAAG,QAAA,EAAAI,IAAA;cACAC,IAAA;YACA;UACA;YACAN,UAAA,CAAAC,QAAA,IAAAH,aAAA,CAAAG,QAAA;UACA;QACA;QACA,OAAAD,UAAA;MACA,WAAAL,KAAA,CAAAC,QAAA,CAAAC,MAAA;QACA,KAAAK,MAAA,CAAAC,IAAA;UACAC,OAAA;UACAE,IAAA;QACA;QACA;MACA;QACA,KAAAJ,MAAA,CAAAC,IAAA;UACAC,OAAA;UACAE,IAAA;QACA;QACA;MACA;IACA;IACAC,gBAAAZ,KAAA;MACA,IACAA,KAAA,CAAAa,OAAA,CAAAC,YAAA,eACAd,KAAA,CAAAC,QAAA,CAAAG,IAAA,YAAAW,IAAA,IACAf,KAAA,CAAAC,QAAA,CAAAG,IAAA,CAAAO,IAAA,IACAX,KAAA,CAAAC,QAAA,CAAAG,IAAA,CAAAO,IAAA,CAAAK,WAAA,GAAAC,QAAA,UACA;QACA,MAAAC,MAAA,OAAAC,UAAA;QAEA,MAAAC,OAAA,OAAAC,OAAA,EAAAC,OAAA,EAAAC,MAAA;UACAL,MAAA,CAAAM,MAAA;YACA;cACA,MAAAC,UAAA,GAAA/B,IAAA,CAAAC,KAAA,CAAAuB,MAAA,CAAAQ,MAAA;cACA1B,KAAA,CAAAC,QAAA,CAAAG,IAAA,GAAAqB,UAAA;cACAF,MAAA,CAAAvB,KAAA;YACA,SAAA2B,UAAA;cACAJ,MAAA,CAAAI,UAAA;YACA;UACA;UAEAT,MAAA,CAAAU,OAAA;YACAL,MAAA,CAAAvB,KAAA;UACA;UAEAkB,MAAA,CAAAW,UAAA,CAAA7B,KAAA,CAAAC,QAAA,CAAAG,IAAA;QACA;QAEAgB,OAAA,CAAAU,KAAA,CAAAC,GAAA;UACA,KAAAxB,MAAA,CAAAC,IAAA;YACAC,OAAA,EAAAsB,GAAA,CAAA9B,QAAA,CAAAG,IAAA;YACAO,IAAA;UACA;QACA;MACA;IACA;IACAqB,eAAAC,IAAA;MACA,KAAAA,IAAA;MACA,OAAA1C,MAAA,CAAA0C,IAAA,EAAAC,MAAA;IACA;IACAC,6BAAAF,IAAA;MACA,KAAAA,IAAA;MACA,OAAA1C,MAAA,CAAA0C,IAAA,EAAAC,MAAA;IACA;IACAE,qBAAAH,IAAA;MACA,KAAAA,IAAA;MACA,OAAA1C,MAAA,CAAA0C,IAAA,EAAAC,MAAA;IACA;IACAG,YAAAC,MAAA;MACA,MAAAC,QAAA,OAAAC,QAAA;MACAC,MAAA,CAAAC,IAAA,CAAAJ,MAAA,EAAAK,OAAA,CACAC,GAAA,KAAAN,MAAA,CAAAM,GAAA,KAAAN,MAAA,CAAAO,EAAA,KAAAN,QAAA,CAAAO,MAAA,CAAAF,GAAA,EAAAN,MAAA,CAAAM,GAAA,EACA;MACA,OAAAL,QAAA;IACA;EACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}